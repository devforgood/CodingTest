#include <iostream>
#include <algorithm>

using namespace std;

int dp[1001][1001];

int main() 
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);

	int n, k;
	cin >> n >> k;

	for (int i = 0; i <= n; ++i)
		dp[i][0] = 1;

	dp[1][1] = 1;

	for (int i = 2; i <= n; ++i)
	{
		for (int j = 1; j * 2 <= i + 1; ++j)
		{
			// n번째 색을 선택하는 경우 인접하지 못한다는 조건에 의해 n-1번째 색은 절대로 선택할 수 없다. 
			// 따라서 n-2개의 색에서 k-1개를 고르면 되므로 dp[n-2][k-1]이다.
			// n번째 색을 선택하지 않는 경우 n번째 색이 없는 것과 마찬가지 이므로
			// n-1개의 색에서 k개를 고르면 되므로 dp[n-1][k]이다

			dp[i][j] = (dp[i - 2][j - 1] + dp[i - 1][j]) % 1000000003;
		}
	}

	// 일렬로 배열되어 있는 상황을 어떻게 고리로 변형시키느냐는 문제만 남았다
	// 의외로 간단하다.n개의 색 고리가 있을 때 
	// 1. 첫 번째 색(12시 방향에 있는 색)을 고른다고 가정해보자.
	// 그러면 그 색을 포함해 왼쪽 색과 오른쪽 색은 자동적으로 고를 수 없다.
	// 그러므로 일렬로 있을 때 n - 3개의 색에서 k - 1개의 색을 고르는 것과 동일해진다. 
	// 2. 첫번째 색을 고르지 않는다고 가정해보면 일렬로 있을 때 n - 1개의 색에서 k개의 색을 고르는 것과 동일해진다.


	cout << (dp[n - 3][k - 1] + dp[n - 1][k]) % 1000000003;
}